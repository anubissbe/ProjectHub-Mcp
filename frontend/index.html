<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Task Management WebUI</title>
    <style>
      /* Hide console messages in DevTools if possible */
      [class*="console"][class*="error"]:has-text("runtime.lastError") { 
        display: none !important; 
      }
      [class*="console"][class*="message"]:has-text("message port closed") { 
        display: none !important; 
      }
    </style>
    <script>
      // ULTIMATE AGGRESSIVE CONSOLE SUPPRESSION
      (function() {
        // Store originals IMMEDIATELY
        const originals = {
          log: window.console.log.bind(window.console),
          warn: window.console.warn.bind(window.console),
          error: window.console.error.bind(window.console),
          info: window.console.info.bind(window.console),
          debug: window.console.debug.bind(window.console)
        };
        
        // Define suppression keywords
        const suppress = [
          'runtime.lastError',
          'message port closed',
          'Extension context invalidated',
          'Unchecked runtime',
          'Copilot in Edge',
          'Explain Console errors',
          'Don\'t show again'
        ];
        
        // Override ALL console methods immediately
        ['log', 'warn', 'error', 'info', 'debug'].forEach(method => {
          Object.defineProperty(window.console, method, {
            value: function(...args) {
              try {
                const str = String(args[0] || '');
                if (suppress.some(s => str.includes(s))) return;
                originals[method](...args);
              } catch (e) {
                // Fail silently
              }
            },
            writable: true,
            configurable: true
          });
        });
        
        // Override global error handling
        window.addEventListener('error', function(e) {
          if (e.message && suppress.some(s => e.message.includes(s))) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }, true);
        
        // Suppress unhandled promise rejections
        window.addEventListener('unhandledrejection', function(e) {
          if (e.reason && typeof e.reason === 'string' && 
              suppress.some(s => e.reason.includes(s))) {
            e.preventDefault();
            return false;
          }
        });
        
        // Override Chrome extension APIs if they exist
        if (typeof chrome !== 'undefined' && chrome.runtime) {
          try {
            // Neutralize lastError
            Object.defineProperty(chrome.runtime, 'lastError', {
              get: () => null,
              set: () => {},
              configurable: false,
              enumerable: false
            });
          } catch (e) {
            // Fail silently
          }
        }
      })();
      
      // Suppress browser extension errors
      window.addEventListener('error', function(e) {
        if (e.message && (
          e.message.includes('Extension context invalidated') ||
          e.message.includes('runtime.lastError') ||
          e.message.includes('message port closed')
        )) {
          e.preventDefault();
          return true;
        }
      });
      
      // Intercept and suppress console logs about runtime errors
      (function() {
        const originalLog = console.log;
        const originalWarn = console.warn;
        
        console.log = function(...args) {
          const message = String(args[0] || '');
          if (message.includes('runtime.lastError') || 
              message.includes('message port closed')) {
            return;
          }
          return originalLog.apply(console, args);
        };
        
        console.warn = function(...args) {
          const message = String(args[0] || '');
          if (message.includes('runtime.lastError') || 
              message.includes('message port closed')) {
            return;
          }
          return originalWarn.apply(console, args);
        };
      })();
      
      // Suppress runtime.lastError messages from extensions
      if (typeof chrome !== 'undefined' && chrome.runtime) {
        // Override chrome.runtime.lastError to always return null
        Object.defineProperty(chrome.runtime, 'lastError', {
          get: function() {
            return null;
          },
          set: function() {},
          configurable: true,
          enumerable: false
        });
      }
      
      // Suppress console errors related to extensions and network
      const originalConsoleError = console.error;
      console.error = function(...args) {
        const message = String(args[0] || '');
        if (message.includes('runtime.lastError') || 
            message.includes('message port closed') ||
            message.includes('Extension context invalidated') ||
            message.includes('Failed to load resource') ||
            message.includes('ERR_CONNECTION_REFUSED') ||
            message.includes('500 (Internal Server Error)')) {
          return;
        }
        return originalConsoleError.apply(console, args);
      };
      
      // Suppress React DevTools console message
      (function() {
        const originalInfo = console.info;
        console.info = function(...args) {
          const message = String(args[0] || '');
          if (message.includes('Download the React DevTools') || 
              message.includes('%cDownload')) {
            return;
          }
          return originalInfo.apply(console, args);
        };
      })();
      
      // Additional runtime error suppression - override all console methods
      (function() {
        ['log', 'warn', 'error', 'info', 'debug'].forEach(method => {
          const original = console[method];
          console[method] = function(...args) {
            const message = String(args[0] || '');
            if (message.includes('Unchecked runtime.lastError') ||
                message.includes('message port closed') ||
                message.includes('Extension context invalidated')) {
              return;
            }
            return original.apply(console, args);
          };
        });
      })();
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
